# 캡슐화

객체를 구성할 때는, 관련된 속성과 동작을 잘 분석하여 합리적으로 캡슐화해야 하며 꼭 필요한 인터페이스만 노출하고 세부 구현은 숨겨 최소한의 지식만으로 객체를 활용할 수 있도록 추상화해야 한다. 캡슐화는 다음 두 가지 측면이 있다.
- 객체의 속성과 행위를 하나로 묶고,
- 실제 구현 내용의 일부를 외부에 감춰 은닉한다.

**정보 은닉**의 목적은 "몰라도 된다"라는 것으로, 프로그래밍의 부품인 객체는 꼭 필요한 부분만 공개하고 사용자가 굳이 몰라도 되는 부분은 숨겨야 한다는 것을 원칙으로 한다. 클래스의 멤버를 숨길 때는 액세스 지정자를 사용한다.

**정보 은폐**는 최소한의 정보만 공개하여 객체를 쉽게 사용할 수 있도록 하며 민감한 정보를 감춰 실수를 원천적으로 방지한다.

## 프렌드
### 프렌드 함수
정보 은폐를 한 상황에서도 비효율적인 경우가 있어, 특정 대상에 대해 모든 멤버에게 공개할 수 있는 기능이다. 프렌드로 지정되면 액세스 지정자에 상관없이 모든 멤버를 읽을 수 있다.    
따라서, 외부에 전역 함수를 정의하고 양쪽 클래스에 프렌드로 지정한다. 

### 프렌드 클래스
두 개의 클래스가 서로 밀접한 관계이고 상대편의 멤버를 참조해야 한다면 클래스를 통째로 프렌드로 지정하기도 한다.

### 프렌드 멤버 함수
클래스끼리 프렌드가 되는 것은 양쪽의 멤버를 공유하는 편리한 방법이지만, 상대편 멤버를 읽을 필요가 없는 함수까지도 권한을 가지게 되어 실수할 가능성이 높아진다. 이럴 때, 특정 멤버 함수에 대해서만 프렌드로 지정한다.

### 프렌드의 특성
> 프렌드 지정은 **단방향**이다.    
> 양쪽이 자유롭게 읽으려면 양쪽 클래스가 서로 프렌드로 지정해야 한다.    
> 프렌드 지정은 전이되지 않으며, 프렌드의 프렌드 관계는 인정하지 않는다.    
> 복수의 대상에 대해 프렌드 지정을 할 수는 있지만, 한 번에 하나씩만 선언이 가능하다.    
> 프렌드 관계는 상속되지 않는다. 즉, 프렌드로 지정한 클래스의 파생 클래스는 프렌드로 인정되지 않는다.


## 정적 멤버
### this
this 인수는 함수를 호출한 객체의 포인터이며, 멤버를 참조하는 모든 문장 앞에 this->가 암시적으로 적용된다. C++ 언어는 명시적으로 자신이 사용할 데이터의 주소를 받기 위해 this 포인터를 사용한다.

### 정적 멤버 변수
정적 멤버 변수는 클래스 바깥에 선언되지만, 클래스에 소속되며 객체별로 할당되지 않고 모든 객체가 공유한다. 정적 멤버 변수는 클래스 외부에 :: 연산자와 함께 소속을 밝혀 별도로 정의하고 초기화한다. 단일 소스 파일일 때는 클래스 선언문 바로 아래에 정의하며, 클래스를 별도의 모듈로 작성할 때에는 헤더 파일에 선언만 들어가므로 정적 멤버에 대한 정의는 구현 파일에 작성한다.

### 정적 멤버 함수
정적 멤버 함수는 객체가 아닌 클래스와 연관되어 모든 객체에 공통적인 작업을 처리한다. 함수 원형 앞에 static 키워드를 붙이며 외부에 작성할 때는 static 키워드를 생략한다.

### 정적 멤버의 활용
> 딱 한번만 해야 하는 전역 자원의 초기화   
> 읽기 전용 자원의 초기화   
> 모든 객체가 공유하는 정보   

## 상수 멤버
상수 멤버는 값이 결정되면 변경할 수 없는 멤버로, const 지정자를 붙인다.
* static과 const를 같이 붙이면 공유 상수가 되어, 클래스에 포함되며 딱 한 카피만 존재하여 메모리가 절약되며 값을 바꿀 수도 없다.

### 상수 멤버 함수
상수 멤버 함수는 객체의 상태를 읽기만 하는 함수로, 멤버 변수를 읽기만 하고 변경하지 않는다면 const 지정자를 붙여 상수 함수로 선언한다.

### mutable
mutable 지정자는 상수 함수나 상수 객체는 메버를 읽을 수만 있고 변경할 수는 없다는 규칙에 대한 예외를 지정하여 이 속성을 가지는 멤버는 객체의 상수성과 상관없이 언제나 수정이 가능하도록 한다.